# 路由

## 1.路由介绍

路由器：路由器是用来管理/调度各个路由的

 对于一个应用来说，一般路由器只需要一个。但是路由是有多个的

作用：单页面web应用开发

## 2.单页面应用

### 2.1传统web应用

传统的web应用 ，又叫做多页面web应用：核心是一个web站点有多个HTML页面组成的，当点击事件触发切换页面，所以当前页面会全部刷新

## 3.路由的工作原理

### 3.1 介绍

每一个路由都是由key和 value组成 例如`key1+value1==>route1`

路由的本质：应该路由表达了了一组对应关系

路由器的本质：管理多组对应关系

## 4.路由的实现

### 4.1安装路由

`vue2`安装`router@3`

`vue3`安装`router@4`

```vue
npm i vue-router@3
```

### 4.2 导入router插件并使用

#### 4.2.1.创建一个路由的`js`文件

```vue
//导入vue-router插件
import VueRouter from "vue-router";

//导入组件
import HeBei from "@/components/HeBei.vue";
import HeNan from "@/components/HeNan.vue";
import City from "@/components/City.vue";

const router=new VueRouter({
    routes :[
        {
			//一级路由
			//路由的key（路径）（注意路径要带/）
            path:"/hebei",
			//路由的value （组件）
            component:HeBei,
            children:[
                {
					//解决路径太长问题 注意：如果要使用路由模式的话必须使用对象模式 不能使用字符串形式
					name:"shi",
					//二级路由
					//注意对于子路由这个path 不要以/开始 系统会自动添加
                    path:"City",
                    component:City,
                },
            ],
        },
        {
			//一级路由
            path:"/henan",
            component:HeNan,
        },
    ]
})
export default router
```





#### 4.2.2main.js中设置

```vue
//导入vue-router插件
import VueRouter from "vue-router"
//导入路由器对象
import router from '路由文件位置' 
//使用vue-router插件
Vue.use(VueRouter)
new Vue({
  router: router,
  render: h => h(App),
}).$mount('#app')
```



#### 4.2.3App.vue

```vue
//to后就是路由js中的路径
<router-link to="./hebei" active-class="selected">河北省</router-link>
<router-link to="./henan" active-class="selected">河南省</router-link>
//路由视图 其实就是路由的占位的作用
<router-view></router-view>
//当点中河北省 在路由视图中展示
```

#### 4.2.4query传参

##### 4.2.4.1字符串形式

?后面跟参数

```vue
<router-link to="./hebei/City?a1=长安区&a2=富华区&a3=新华区" active-class="selected">石家庄</router-link>
<router-link :to="`/hebei/city?a1=${sjz[0]}&a2=${sjz[1]}&a3=${sjz[2]}`" active-class="selected">石家庄</router-link>
//两种方式
```

##### 4.2.4.1对象传参

```vue
<router-link active-class="selected" :to="{
        path : '/hebei/city',
        query:{
          a1:sjz[0],
          a2:sjz[1],
          a3:sjz[2],
        }
      }">石家庄</router-link>
```

#### 4.2.5.params方式传参

##### 4.2.5.1字符串形式

```vue
//直接传
<router-link active-class="selected" to="/hebei/shi/石家庄/石家庄市/石家庄区">石家庄</router-link>
//数组的形式
<router-link active-class="selected" :to="`/hebei/shi/${sjz[0]}/${sjz[1]}/${sjz[2]}`">石家庄</router-link>
//注意组件中传参的时候要说明/石家庄/石家庄市/石家庄区是参数不是路径
path:"shi/:a1/:a2/:a3",
```

##### 4.2.5.2对象传参

```vue
<router-link active-class="selected" :to="{
        //然后使用路由的params参数必须要和路由的name参数对应不能使用路由的path参数
        name:'shi',
        params:{
          a1:sjz[0],
          a2:sjz[1],
          a3:sjz[2],
        }
      }">石家庄</router-link>
```

##### 4.2.5.3.下级路由获取参数

```
 	
 	<li v-for="item in $route.params" :key="item">
        {{item}}
    </li>
```

#### 4.2.6.props配置

在路由配置中使用

```vue
	<li>{{a1}}</li>
    <li>{{a2}}</li>
    <li>{{a3}}</li>
```

简化必须在子组件中设置

```vue
export default {
  name:"CiTy",
  //接受props中的值
  props:['a1','a2','a3'],
}
```

路由中配置

```vue
const router=new VueRouter({
    routes :[
        {
            path:"/hebei",
            component:HeBei,
            children:[
                {
                    name:"shi",
                    path:"shi/:a1/:a2/:a3",
                    component:City,
                    //路由当中设置props函数式学法
                    props(t){//t将会配自动传过来，他代表路径中的对象，变量名随意
                        return{
                            a1:t.params.a1,
                            a2:t.params.a2,
                            a3:t.params.a3,
                        }
                    },
                },
                {
                    name:"han",
                    path:"han",
                    component:City,
					//这种方法只支持params方式传参，不支持query方式
					//将params对象直接转换为props对象,内部自动转换不需要我们操作
                    props:true,
                },
            ],

        },
        {
            path:"/henan",
            component:HeNan,
        },
    ]
})
```

5.路由-push和replace模式

1.浏览器的历史记录是以栈的方式存放地址的

2.历史记录在存放到栈这种数据结构的时候有两种不同的模式

​	第一种：`push`模式

​		以追加的方式，入栈

​	第二种：`replace`模式

​		以替换栈顶元素的方式，入栈

3.浏览器默认的模式是：push模式

4.操作浏览器商店前进和后退的时候，并不会删除栈当前的历史记录，知识向前和向后移动一个指针

5.常用push模式或push+replace模式

6.添加replace

```
:replace="true"
```

## 5.编程式路由导航

定义：通过编译的方式完成路由的切换被称为：编程是路由导航

使用：调用现有的API可以实现路由组件的切换

操作：

1.先获取路由器对象，不是路由对象而是路由器对象

2.this.$route 这个是路由对象 this.$router 获取整个路由器镀锡（路由器对象一般一个项目只有一个）

3.代码实现

```
methods:{
    hebei(){
      //这个是push模式
      this.$router.push({
        path:"/hebei",
      });
    }，
    //这个是replace模式
    henan(){
      this.$router.replace({
        path:"/henan",
      });
    }
  }
```

4.注意 

在使用编程式路由导航是.push以及replace方法会返回一个Promise对象

Promise对象期望你能通过参数的方式给他两个回调函数，一个是成功的回调，一个是失败的回调

如果没有这两个回调函数，则会出错误，怎么解决 在参数位置给两个回调函数

```

methods:{
    hebei(){
    //第一中方法添加两个回调函数
      this.$router.push({
        path:"/hebei"
      },()=>{},()=>{});
    },
    henan(){
    //判断上次访问的路由是否是同一个
    （this.$route.path!="/henan"）//同样可以判断
    if (this.$router.currentRoute.path!='/henan') {
        //给路由跳转
        	this.$router.replace({
        	path:"/henan",
      	});
      }
    }
  }
```

## 6.路由组件的销毁

因为在切换路由组件的时候会销毁上一次的组件

解决办法

```
//第一种所以的组件都不销毁
<!--    <keep-alive>-->
<!--      <router-view></router-view>-->
<!--    </keep-alive>-->
//第二种可以指定某个组件不销毁 组件名
<!--    <keep-alive include="HeBei">-->
<!--      <router-view></router-view>-->
<!--    </keep-alive>-->
//第三种可以设置多个以数组的形式存储
    <keep-alive :include="['HeBei','HeNan']">
      <router-view></router-view>
    </keep-alive>
```

## 7.路由组件的两个钩子

### 7.1普通组件

钩子函数有9个

8个+`this.nextTick`(function(){})

下次DOM渲染的时候钩子执行`nextTick`

### 7.2 路由组件

对于路由组件来说：

钩子函数是：

9+2（`activated`和`deactivated`）

activated ：路由组件被切换的时候调用

deactivated：路由组件被切走的时候调用



## 8.路由守卫

### 8.1定义

不同的守卫其实本质上，就是在不同的时机，不同的位置添加代码 

### 8.2 全局前置路由守卫 

1.代码写到哪里？在创建好的router之后，已经暴露router之前

2.beforeEach中的callback什么时候被调用？在初始化执行一次，以后每一次切换任意组件之前都会被调用。

3.callback可以是普通函数，也可用是箭头函数

4.callback函数中有三个参数： to from next

5.from 参数：from是一个路由对象，表示从哪来（从那个路由切过来的）.起点

6.to 参数：to也是一个路由对象，表示到哪儿去 终点

7.next 参数：这个一个函数，调用这个函数之后，表示方形，可以继续向下走

8.给路由对象添加自定义属性的话，需要在路由对象的meta（路由元）中定义

```vue
//导入vue-router插件

import VueRouter from "vue-router";
import HeBei from "@/components/HeBei.vue";
import HeNan from "@/components/HeNan.vue";
import City from "@/components/City.vue";

const router=new VueRouter({
    routes :[
        {
            path:"/hebei",
            component:HeBei,
            children:[
                {
                    name:"shi",
                    path:"shi/:a1/:a2/:a3",
                    component:City,
                    //路由当中设置props
                    props(t){
                        return{
                            a1:t.params.a1,
                            a2:t.params.a2,
                            a3:t.params.a3,
                        }
                    },
                    meta:{
                        isAuth:true,
                    }
                },
                {
                    name:"han",
                    path:"han",
                    component:City,
                    props:true,
                    meta:{
                        isAuth:true,
                    }
                },
            ],

        },
        {
            path:"/henan",
            component:HeNan,
        },
    ]
})

router.beforeEach((to,from,next)=>{
    let  loginName='zhangsna';
    //默契来说只有2个页面需要验证
    //如果当前比较多的鉴权这里代码就比较繁琐
    //前提要在meta自定义属性不然获取不到
    //解决方式就在路由当中设置一个isAuth属性
    if (to.meta.isAuth){
        if(loginName==='admin'){
            next();
        }else{
            alert("对不起，您没有权限访问该页面");
        }
    }else {
        //方行
        next();
    }
})
export default router;
```

### 8.3 全局后置路由守卫

1.代码写到哪里？在创建好的router之后，已经暴露router之前

2.afterEach中的回调函数什么时候执行？在初始化执行一次，以后每一次切换任意组件之后都会被调用

3.这个回调函数有两个参数：to from。

4.这个回调函数没有next参数，以为没有必要

```vue
router.afterEach((to)=>{
    if (to.meta.title){
        document.title=to.meta.title || '欢迎使用';
    }
})
```

### 8.4 局部路由守卫

#### 8.4.1 path守卫

1.这个局部路由守卫path守卫，代码写到哪里？写到router对象中

2.beforeEnter 本身就是一个函数，参数上没有回调函数了，

3.对于`beforeEnter`来说，参数仍然有三个 ：to ，from，next

4.beforeEnter什么时候被调用？进入‘shi’这个路由前被调用

```vue
{
                    name:"shi",
                    path:"shi/:a1/:a2/:a3",
                    component:City,
                    //路由当中设置props
                    props(t){
                        return{
                            a1:t.params.a1,
                            a2:t.params.a2,
                            a3:t.params.a3,
                        }
                    },
                    meta:{
                        title:"石家庄",
                        isAuth:true,
                    },
                    beforeEnter(to,from,next){
                        let loginName='zhangsan';
                        if(loginName==='admin'){
                            next();
                        }else{
                            alert("对不起，您没有权限访问该页面");
                        }
                    }
                },
```

#### 8.4.2 component守卫

1.这个局部路由守卫component守卫，代码写到哪里？写到component当中（写到组件中的XXX.vue）

2.beforeRouterEnter 执行时机：进入路由组件之前。

3.普通组件不会触发，必须是路由组件财会触发。

```vue
export default {
  name:"CiTy",
  props:['a1','a2','a3'],
  mounted() {
    //所以的路由组件抖音一个属性$router
    // console.log(this.$route.params)
  },
  beforeRouteEnter(to,from,next){
    console.log(`进入之前${to.meta.title}`);
    next();
  },
  beforeRouteLeave(to,from,next){
    console.log(`离开之前${from.meta.title}`);
    next();
  }
}
```

## 9.项目上线

1首先要有安装两个工具JDK和tomcat

2.安装 搜教程并配置环境变量能在`cmd`（黑窗口执行）

3.将前端打包指令 `npm run build`

4.找到`dist`文件夹并将内容复制到tomcat安装目录中的\webapps\ROOT将其中内容替换

5.找到tomcat中bin文件用黑窗口执行 startup.bat

6.完成可以访问 注意 前端项目中如果vue-router(路由)模式是history 要改成hash模式不然不能刷新

7.解决history问题 前端人员了解即可后端人员处理

在ROOT文件中添加一个WEB-INF 添加一个web.xml 

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee
                      http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
  version="4.0"
  metadata-complete="true">

    <error-page>
        <error-code>404</error-code>
        <location>/index.html</location>
    </error-page>

</web-app>

```



