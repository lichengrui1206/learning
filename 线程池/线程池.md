# 线程池

### 概念：

线程池是一种软件设计模式，用于有效管理线程的创建、执行和销毁，以优化系统资源的使用、提高程序的执行效率和响应速度。它是多线程编程中的一个重要概念，特别适用于需要处理大量短期并行任务的应用场景。

#### 基本概念

线程池预先创建一定数量的线程，并将这些线程维护在一个池中。当有新任务到来时，线程池不是为每个任务创建新的线程，而是从池中选择一个可用线程来执行该任务。执行完毕后，线程不会被销毁，而是返回线程池等待下一个任务，实现了线程的复用。

#### 主要组成部分

- **线程池管理器**：负责创建、销毁线程池，以及对线程池进行监控和管理。
- **工作线程**：线程池中的线程，等待任务并执行。
- **任务队列**：用于存放待处理的任务，当没有空闲线程时，新来的任务会被放入队列中等待。
- **任务接口**：每个任务都需要实现的一个接口，以便工作线程能够执行它。

#### 工作机制

1. **任务提交**：应用程序向线程池提交任务。
2. **任务调度**：线程池根据当前线程的使用情况，从任务队列中取出任务分配给线程执行。
3. **线程复用**：任务执行完毕，线程返回线程池等待新的任务，而不是被销毁。
4. **动态调整**：线程池可以根据实际需求动态调整线程数量，如达到最大线程数限制时，超出的任务将排队等待。

#### 优点

- **减少线程创建和销毁的开销**：线程创建和销毁需要消耗CPU资源，线程池重用线程减少了这种开销。
- **提高响应速度**：线程创建好并准备好执行，可以迅速响应新任务。
- **控制并发数量**：合理设置线程池大小，可以有效避免过多线程导致的资源竞争和上下文切换开销。
- **提高资源利用率**：通过复用线程，减少了系统资源的浪费。

#### 应用场景

线程池广泛应用于服务器端程序、数据库连接管理、Web服务器、文件I/O操作等需要高性能并发处理的场景。

### 创建线程池

```java
/*
        第一个参数含义是线程池中核心线程数，默认是1
        第二个参数含义是线程池中允许的最大线程数，默认是Integer.MAX_VALUE
        第三个参数含义是存活时间，默认是60秒
        第四个参数含义是时间单位，默认是TimeUnit.SECONDS(秒)
        第五个参数含义是线程池的阻塞队列
        第六个参数含义是线程池工厂对象
        第七个参数含义是拒绝策略，默认是ThreadPoolExecutor.AbortPolicy()
        * */

        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(3, 5, 1L, TimeUnit.SECONDS, new ArrayBlockingQueue<>(3), Executors.defaultThreadFactory(), new ThreadPoolExecutor.AbortPolicy());
//        启动所以线程
threadPoolExecutor.prestartAllCoreThreads();
```



在创建线程池的时候为什么不推荐使用Executor来创建线程池

答：`Executors`是一个工厂类，它提供了一系列用于创建不同类型的线程池的静态方法。尽管 `Executors` 提供了一种快速创建线程池的方式，但有一些原因不建议直接使用它来创建线程池，尤其是在生产环境中的长期运行应用程序中

简单来说就是在创建线程池的时候参数 像核心线程数还有阻塞队列的大小都默认值了而且他的默认值也非常的打不适合项目使用

1. **缺乏对线程池的精细控制**：`Executors` 提供的方法通常创建一些简单的线程池，如固定大小的线程池、单线程线程池等。然而，这些线程池的配置通常是有限制的，难以进行进一步的定制和优化。
2. **可能引发内存泄漏**：一些 `Executors` 创建的线程池，特别是 `FixedThreadPool` 和 `SingleThreadExecutor`，使用无界队列来存储等待执行的任务。这意味着如果任务提交速度远远快于任务执行速度，队列中可能会积累大量未执行的任务，可能导致内存泄漏。
3. **不易处理异常**：`Executors` 创建的线程池默认使用一种默认的异常处理策略，通常只会将异常打印到标准输出或记录到日志中，但不会提供更多的控制。这可能导致异常被忽略或无法及时处理。
4. **不支持线程池的动态调整**：某些线程池应该支持动态调整线程数量以应对不同的负载情况。`Executors` 创建的线程池通常是固定大小的，不容易进行动态调整。
5. **可能导致不合理的线程数目**：一些 `Executors` 方法创建的线程池默认将线程数目设置为非常大的值，这可能导致系统资源的浪费和性能下降。





#### 流程图

execute(Runnable command)方法执行流程图

![image-20240602202908382](C:\Users\qwxqy\AppData\Roaming\Typora\typora-user-images\image-20240602202908382.png)

### 线程池的状态

#### 五种状态

1. **Running（运行）**: 这是线程池的初始状态。在这个状态下，线程池能够接收新任务，也会处理已经添加到队列中的任务。线程池会根据配置创建并维护一定数量的线程来执行任务。
2. **ShutDown（关闭）**: 当调用了线程池的 shutdown() 方法后，线程池进入此状态。此时，线程池不再接受新的任务提交，但它会继续处理队列中已存在的任务直到全部完成。
3. **Stop（停止）**: 如果调用了 shutdownNow() 方法，线程池会进入 Stop 状态。这个操作不仅会阻止新任务的提交，还会尝试中断正在执行的任务，并返回未开始执行的任务列表。这是一种相对粗暴的停止方式，旨在尽快关闭线程池。
4. **Tidying（整理）**: 当所有任务已完成（包括已提交的任务和正在执行的任务因中断而终止），并且没有其他线程需要被终止时，线程池就会过渡到 Tidying 状态。在这个阶段，线程池会调用 terminated() 钩子方法准备进行清理工作。
5. **Terminated（终止）**: 经过 Tidying 状态后，terminated() 方法执行完毕，线程池就进入了 Terminated 状态。这时，线程池生命周期结束，所有的资源都被回收。

#### 转换线程池状态代码

```java
threadPoolExecutor.shutdown();//停止线程池 ShutDown
threadPoolExecutor.shutdownNow();//停止所有线程 Stop
```

### 外包线程

理解：如果在队列循环获取不到任务的话会在一定时间后退出循环并消失

控制这个逻辑的属性是 allowCoreThreadTimeOut 默认为false

![image-20240603104859461](C:\Users\qwxqy\AppData\Roaming\Typora\typora-user-images\image-20240603104859461.png)

### 如何设置核心线程数

根据电脑CPU的核心数来进行判断的肯定要先获取CPU核心数

```
//获取电脑的CPU的核心数
int corePoolSize = Runtime.getRuntime().availableProcessors();
```

线程池里面的核心线程数为 

第一种公式：CPU的核心数+1

第二种公式：CPU的核心数*2

第三种公式：CPU的核心数*（1+线程等待时间/线程运行总时间）
